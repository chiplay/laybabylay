// Generated by CoffeeScript 1.6.3
(function() {
  var backboneSync, collection, dualSync, localStorage, localsync, model, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  backboneSync = window.backboneSync, localsync = window.localsync, dualSync = window.dualSync, localStorage = window.localStorage;

  _ref = {}, collection = _ref.collection, model = _ref.model;

  beforeEach(function() {
    backboneSync.calls = [];
    localsync('clear', {}, {
      ignoreCallbacks: true,
      storeName: 'eyes/'
    });
    collection = new Backbone.Collection({
      id: 123,
      vision: 'crystal'
    });
    collection.url = 'eyes/';
    return model = collection.models[0];
  });

  describe('using Backbone.sync directly', function() {
    return it('should save and retrieve data', function() {
      var errorCallback, fetched, saved, successCallback, _ref1;
      _ref1 = {}, successCallback = _ref1.successCallback, errorCallback = _ref1.errorCallback;
      saved = false;
      runs(function() {
        localStorage.clear();
        successCallback = jasmine.createSpy('success').andCallFake(function() {
          return saved = true;
        });
        errorCallback = jasmine.createSpy('error');
        return dualsync('create', model, {
          success: successCallback,
          error: errorCallback
        });
      });
      waitsFor((function() {
        return saved;
      }), "The success callback for 'create' should have been called", 100);
      runs(function() {
        expect(backboneSync.calls.length).toEqual(1);
        expect(successCallback).toHaveBeenCalled();
        expect(errorCallback).not.toHaveBeenCalled();
        return expect(localStorage.length).toBeGreaterThan(0);
      });
      fetched = false;
      runs(function() {
        successCallback = jasmine.createSpy('success').andCallFake(callbackTranslator.forBackboneCaller(function(resp) {
          fetched = true;
          return expect(resp.vision).toEqual('crystal');
        }));
        errorCallback = jasmine.createSpy('error');
        return dualsync('read', model, {
          success: successCallback,
          error: errorCallback
        });
      });
      waitsFor((function() {
        return fetched;
      }), "The success callback for 'read' should have been called", 100);
      return runs(function() {
        expect(backboneSync.calls.length).toEqual(2);
        expect(successCallback).toHaveBeenCalled();
        return expect(errorCallback).not.toHaveBeenCalled();
      });
    });
  });

  describe('using backbone models and retrieving from local storage', function() {
    it("fetches a model after saving it", function() {
      var fetched, retrievedModel, saved;
      saved = false;
      runs(function() {
        return model.save({}, {
          success: function() {
            return saved = true;
          }
        });
      });
      waitsFor((function() {
        return saved;
      }), "The success callback for 'save' should have been called", 100);
      fetched = false;
      retrievedModel = new Backbone.Model({
        id: 123
      });
      retrievedModel.collection = collection;
      runs(function() {
        return retrievedModel.fetch({
          remote: false,
          success: function() {
            return fetched = true;
          }
        });
      });
      waitsFor((function() {
        return fetched;
      }), "The success callback for 'fetch' should have been called", 100);
      return runs(function() {
        return expect(retrievedModel.get('vision')).toEqual('crystal');
      });
    });
    return it("works with an idAttribute other than 'id'", function() {
      var NonstandardModel, fetched, retrievedModel, saved, _ref1;
      NonstandardModel = (function(_super) {
        __extends(NonstandardModel, _super);

        function NonstandardModel() {
          _ref1 = NonstandardModel.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        NonstandardModel.prototype.idAttribute = 'eyeDee';

        NonstandardModel.prototype.url = 'eyes/';

        return NonstandardModel;

      })(Backbone.Model);
      model = new NonstandardModel({
        eyeDee: 123,
        vision: 'crystal'
      });
      saved = false;
      runs(function() {
        return model.save({}, {
          success: function() {
            return saved = true;
          }
        });
      });
      waitsFor((function() {
        return saved;
      }), "The success callback for 'save' should have been called", 100);
      fetched = false;
      retrievedModel = new NonstandardModel({
        eyeDee: 123
      });
      runs(function() {
        return retrievedModel.fetch({
          remote: false,
          success: function() {
            return fetched = true;
          }
        });
      });
      waitsFor((function() {
        return fetched;
      }), "The success callback for 'fetch' should have been called", 100);
      return runs(function() {
        return expect(retrievedModel.get('vision')).toEqual('crystal');
      });
    });
  });

  describe('using backbone collections and retrieving from local storage', function() {
    return it('loads a collection after adding several models to it', function() {
      var fetched, saved;
      saved = 0;
      runs(function() {
        var id, newModel, _i;
        for (id = _i = 1; _i <= 3; id = ++_i) {
          newModel = new Backbone.Model({
            id: id
          });
          newModel.collection = collection;
          newModel.save({}, {
            success: function() {
              return saved += 1;
            }
          });
        }
        return waitsFor((function() {
          return saved === 3;
        }), "The success callback for 'save' should have been called for id #" + id, 100);
      });
      fetched = false;
      runs(function() {
        return collection.fetch({
          remote: false,
          success: function() {
            return fetched = true;
          }
        });
      });
      waitsFor((function() {
        return fetched;
      }), "The success callback for 'fetch' should have been called", 100);
      return runs(function() {
        expect(collection.length).toEqual(3);
        return expect(collection.map(function(model) {
          return model.id;
        })).toEqual([1, 2, 3]);
      });
    });
  });

  describe('success and error callback parameters', function() {
    return it("passes back the response into the remote method's callback", function() {
      var callbackResponse;
      callbackResponse = null;
      runs(function() {
        model.remote = true;
        return model.fetch({
          success: function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return callbackResponse = args;
          }
        });
      });
      waitsFor((function() {
        return callbackResponse;
      }), "The success callback for 'fetch' should have been called", 100);
      return runs(function() {
        expect(callbackResponse[0]).toEqual(model);
        return expect(callbackResponse[1]).toEqual(model.attributes);
      });
    });
  });

}).call(this);
